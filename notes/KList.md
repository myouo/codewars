
##### 任何类型的指针都可以转换为void*

这是因为void*是一个通用指针类型，它可以指向任何类型的数据。这种特性使得void*在需要处理不同类型数据的通用函数中特别有用。

##### void* 可以转换为任何类型的指针。

这是void*作为通用指针的另一个重要特性，允许我们在需要时将其转换回特定类型的指针。这种双向转换的特性使得void*在实现多态性时非常有用。

##### 指针的安全隐患

- 空指针引用可能导致程序崩溃  
- 悬空指针（指向已释放的内存）可能导致不可预知的结果  
- 越界访问可能破坏其他数据  
- 内存泄漏等问题

##### 指针大小和系统位数有关

16位系统是2个字节，32位系统是个4字节，64位系统是8个字节

### this 指针

[interview](../interview/README.md)

1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用 `this` 指针：
    1. 为实现对象的链式引用；
    2. 为避免对同一对象进行赋值操作；
    3. 在实现一些数据结构时，如 `list`。