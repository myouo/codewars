# 简单介绍
## 1. **友元函数（friend function）**

### (1) 定义

友元函数是 **可以访问类的私有成员和保护成员的非成员函数**。  
它不是类的成员，但被类授权访问私有数据。

```cpp
#include <iostream>
using namespace std;

class Box {
private:
    int width;
public:
    Box(int w) : width(w) {}

    // 声明友元函数
    friend void printWidth(Box b);
};
// 友元函数可以访问私有成员
void printWidth(Box b) {
    cout << "Width: " << b.width << endl;
}

int main() {
    Box b(10);
    printWidth(b);  // 可以访问 private width
}
// 输出
// Width: 10
```

### (2) 特点

1. 不是成员函数，不属于类，但有访问权限。  
2. 可以是普通函数、类的成员函数或者模板函数。  
3. 声明在类里面，用 `friend` 关键字。

## 2. **友元类（friend class）**

### (1) 定义

一个类声明另一个类为友元类后，友元类的所有成员函数都可以访问该类的私有和保护成员。
```cpp
#include <iostream>
using namespace std;

class Box {
private:
    int width;
public:
    Box(int w) : width(w) {}

    // 声明 FriendBox 为友元类
    friend class FriendBox;
};
class FriendBox {
public:
    void showWidth(Box b) {
        cout << "Width: " << b.width << endl; // 可以访问私有成员
    }
};
int main() {
    Box b(20);
    FriendBox fb;
    fb.showWidth(b);  // 可以访问 Box::width
}

// 输出
// Width: 20
```

## 3. **使用场景**

- **友元函数**  
	- 当某个非成员函数需要访问类的私有数据，比如重载运算符（`operator<<` / `operator>>`）
	- 提供全局函数接口，但仍能操作类内部数据  
- **友元类**  
    - 两个类紧密相关，需要访问彼此的私有数据          
    - 例如链表节点类和链表类，树节点类和树类

## 4. **注意事项**

1. **不是继承关系**  
    - 友元关系不会传递，也不会继承。  
    `class A { friend class B; }; class C : public B {}; // C 不是 A 的友元`
    
2. **破坏封装**  
    - 滥用友元会让类的私有数据暴露，应该只用于必要场景。

3. **声明顺序**  
    - 友元函数/类必须在被声明的类中声明，编译器才能识别。

# 类内运算符重载（友元）

## 1. 成员函数重载与友元函数重载

### （1）成员函数重载

成员函数重载运算符时，左操作数必须是类对象（或引用/指针）。

```cpp
class Number {
    int value;
public:
    Number(int v) : value(v) {}
    Number operator+(const Number& rhs) const { // 左操作数是 *this
        return Number(value + rhs.value);
    }
};

int main() {
	Number a(1), b(2);
	Number c = a + b;
	Number d = a + 3;
	return 0;
}
```

奇怪，怎么这两个都能运行？我分明还没有写对int的重载…  
查阅资料发现，这是c++的隐式转换机制——

注意到出现问题的语句为 **`Number d = a + 2;`**

编译器看到：
1. 左操作数 `a` 是 `Number`。    
2. 右操作数 `2` 是 `int`，而 `Number::operator+(const Number&)` 需要一个 `Number` 类型参数。

此时，编译器会尝试 **寻找隐式转换**，发现 `Number(int)` 可以把 `2` 转换成 `Number(2)`，所以 `a + 2` 等价于  
`a.operator+(Number(2));`  
因此代码能编译并运行。

 ***反制方法：***

将构造函数用`explicit`关键字修饰，即可禁止隐式转换，仅允许显式调用。

```cpp
class Number {
    int value;
public:
    explicit Number(int v) : value(v) {} // explicit
    Number operator+(const Number& rhs) const { return Number(value + rhs.value); }
};

int main() {
    Number a(1);
    Number d = a + 2; // ❌ 编译错误，需要显式转换
    Number e = a + Number(2); // ✅ 可以
}
```

再来说说`explicit`。

```cpp
#include <bits/stdc++.h>

class Number {
    int value;
public:
	explicit Number(int v) { value = v; }  // 非 explicit
	friend void printNumber(const Number&) /*const*/; // non-member function cannot have 'const' qualifier（非成员函数不许用const来修饰）
};
void printNumber(const Number& n) /*const*/	{std::cout << n.value << '\n';}

int main() {
    //printNumber(10);  // 无法通过编译(添加了explicit关键字，禁止隐式转换，因此c++无法将int转换为Number类型)
    printNumber(Number(10)); // 可用
    printNumber(static_cast<Number>(10)); // 可用，显式转换
	
	return 0;
}

```

在 C++ 中，`explicit` 主要用于 **防止不必要或危险的隐式类型转换**，避免一些难以察觉的错误。

如果构造函数只有一个参数，且不加 `explicit`，它会被 **隐式类型转换** 调用。

单参函数无需多言。如果构造函数有多个参数，但只要**可以用一个参数调用**，也会产生隐式转换，如：
```cpp
class Point {
public:
    Point(int x, int y = 0) { }
};
Point p = 5; // 会调用 Point(5,0)，隐式转换

//如果不希望这种行为，应该写
explicit Point(int x, int y = 0) { }
```

`explicit` 的核心作用是 **禁止隐式转换，只允许显式调用**。推荐所有单参数构造函数 **默认加 explicit**，除非明确希望允许隐式转换；所有类型转换运算符 **尽量加 explicit**，只在需要隐式转换的场景才去掉。

### (2) 友元函数重载

- 友元函数不是类成员，可以访问私有成员。
- 左右操作数都可以是类对象，也可以是其他类型：
```cpp
class Number {
    int value;
public:
    Number(int v) : value(v) {}
    // 友元函数重载 +
    friend Number operator+(const Number& lhs, const Number& rhs) {
        return Number(lhs.value + rhs.value);
    }
};

Number a(1), b(2);
Number c = a + b;  // OK
Number d = Number(5) + a; // OK

// 和内置类型混用
friend Number operator+(int lhs, const Number& rhs) {
    return Number(lhs + rhs.value);
}

//如
Number z = 2 + Number(3);
```

最后附上一个gpt给的模板

> 支持任意数值类型 **左右加减 + 乘除 + 赋值运算**，代码仍然只写一次核心逻辑，非常接近 STL 风格的做法

```cpp
#include <iostream>
using namespace std>

class Number {
private:
    double value;  // 用 double 支持整数和浮点数

public:
    // 构造函数，支持任意可转换类型
    template <typename T>
    Number(T v = 0) : value(static_cast<double>(v)) {}

    // 核心成员运算：Number 与 Number
    Number operator+(const Number& rhs) const { return Number(value + rhs.value); }
    Number operator-(const Number& rhs) const { return Number(value - rhs.value); }
    Number operator*(const Number& rhs) const { return Number(value * rhs.value); }
    Number operator/(const Number& rhs) const { return Number(value / rhs.value); }

    // 复合赋值运算符
    Number& operator+=(const Number& rhs) { value += rhs.value; return *this; }
    Number& operator-=(const Number& rhs) { value -= rhs.value; return *this; }
    Number& operator*=(const Number& rhs) { value *= rhs.value; return *this; }
    Number& operator/=(const Number& rhs) { value /= rhs.value; return *this; }

    // 输出
    void show() const { cout << value << endl; }

    // 模板友元函数，实现左操作数任意类型
    template <typename T>
    friend Number operator+(T lhs, const Number& rhs);
    template <typename T>
    friend Number operator-(T lhs, const Number& rhs);
    template <typename T>
    friend Number operator*(T lhs, const Number& rhs);
    template <typename T>
    friend Number operator/(T lhs, const Number& rhs);
};

// 左操作数任意类型 + Number
template <typename T>
Number operator+(T lhs, const Number& rhs) { return Number(lhs) + rhs; }

template <typename T>
Number operator-(T lhs, const Number& rhs) { return Number(lhs) - rhs; }

template <typename T>
Number operator*(T lhs, const Number& rhs) { return Number(lhs) * rhs; }

template <typename T>
Number operator/(T lhs, const Number& rhs) { return Number(lhs) / rhs; }

// 测试示例
int main() {
    Number a(10), b(5);

    (a + b).show();   // 15
    (a - b).show();   // 5
    (a * b).show();   // 50
    (a / b).show();   // 2

    (a + 3).show();   // 13
    (7 + b).show();   // 12
    (a - 2).show();   // 8
    (20 - b).show();  // 15
    (a * 2).show();   // 20
    (3 * b).show();   // 15
    (a / 2).show();   // 5
    (10 / b).show();  // 2

    // 复合赋值
    a += b; a.show(); // 15
    a -= 5; a.show(); // 10
    a *= 2; a.show(); // 20
    a /= 4; a.show(); // 5

    return 0;
}

```