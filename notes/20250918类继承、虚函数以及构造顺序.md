
[原题链接](https://www.nowcoder.com/questionTerminal/a8ef3d5d6d5d404ea471853bf397ff56)

```c++
#include <bits/stdc++.h>

class father{
public:
	void stru(){std::cout << "father is constructing!\n";};
	virtual void father_two() {std::cout << "this is ur 2nd father...\n";};
	father() {stru();};
};

class son: public father{
public:
	void stru() {std::cout << "that is a son\n";};
	void father_two() override {std::cout << "now it's son here!\n";};
	son() {std::cout << "son is constructing...\n";};
};

class grand: public son{
public:
	void stru() {std::cout << "this is grand......\n";};
	void father_two() override {std::cout << "now it's grand here!\n";};
	grand() {std::cout << "grand is constructing///\n";};
};

int main() {
	father *p = new grand;
	p -> stru();
	p -> father_two();
	return 0;
}
```

拿3个类试验了一下，大概懂了。

**继承链： father -> son -> grand** 

构造顺序规则

**创建子类对象时**，会先调用基类的构造函数，再调用子类的构造函数。因为子类对象中包含基类子对象，必须先把父亲“造好”，才能继续造儿子。

因此构造时会依次调用father()、son()和grand()，输出

> father is constructing!
> son is constructing...
> grand is constructing///

##### 来到 p -> stru()

因为father类的stru不是虚函数，静态绑定到father::stru，输出

> father is constructing!

#### p->father_two()

father_two是虚函数，动态绑定类，而p实际指向一个grand对象，因此调用的是grand::father_two，输出

> now it's grand here!

因此，最终会输出
```
father is constructing!
son is constructing...
grand is constructing
father is constructing!
now it's grand here!
```
