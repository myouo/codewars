```c++
class A {
public:
    void showA() { std::cout << "A\n"; }
};
class B {
public:
    void showB() { std::cout << "B\n"; }
};
class C : public A, public B {
public:
    void showC() { std::cout << "C\n"; }
};

C obj;
obj.showA();  // 来自A
obj.showB();  // 来自B
obj.showC();  // 自己的

//输出
A
B
C
```

以上为多重继承的基本语法。

### 但是，多重继承可能会产生2种问题：

#### 1. 命名冲突

```cpp
// 如果两个基类里有同名函数：
class A {
public:
    void hello() { std::cout << "A\n"; }
};
class B {
public:
    void hello() { std::cout << "B\n"; }
};
class C : public A, public B {};

int main() {
    C obj;
    obj.hello(); // ❌ 二义性，编译错误
}

// 必须显式指定：
obj.A::hello();
obj.B::hello();
```

#### 2.菱形继承

```cpp
class A {
public:
    int x;
};

class B : public A {};
class C : public A {};
class D : public B, public C {};

int main() {
	D obj;
	std::cout << obj.x << "\n";
}

/*
error: non-static member 'x' found in multiple base-class subobjects of type 'A':
    class D -> B -> A
    class D -> C -> A
   14 |     std::cout << obj.x << '\n';
      |                      ^
 note: member found by ambiguous name lookup
    5 |     int x;
      |         ^
1 error generated.
*/


// 解决办法：虚继承
class A {
public:
    int x;
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};

int main() {
	D obj;
	obj.x = 10;
	std::cout << obj.x << "\n";
}
//success
```

